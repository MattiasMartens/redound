- Backpressure in the case of multiple subscribers
  - Principle of least astonishment: probably manage backpressure independently for each subscriber. In some cases this could cause sync issues where two subscribers feed into a single consumer; that's where the runtime clock comes in.
- Errors: we want a clean, standardized paradigm for handling event processing errors and when to terminate sources based on failures in their downstream. It's already established that errors don't propagate directly, but that it is a separate concern handled by the owner of all application sources and sinks.
- Push: nice to be able to synthesize events at a source and then push them upstream to a source so as to induce the data change that would have produced the event. Probably not a concern except in the context of source-capable derivations.
- Source capability: some derivations may use IO in the implementation of their underlying data structure. What this means, in effect, is that their derived data is cached and persists beyond the current runtime. This is useful in the context of extremely large datasets, where sources must use a pull-focused approach instead of querying everything, and some derivations exist that must aggregate source data that is not available in the current runtime. In this case, it also becomes valuable to apply queries to the derivation directly, instead of applying them to the source and waiting for their effects to propagate down. (Of course only the latter approach guarantees that the values are up-to-date, unless the framework user takes extra precautions.) But this also raises the question of if pull-capable derivations should also be push-capable. If they are push-capable, then the derived data can be updated directly as the user wishes to change it. But this means that a derivation can get ahead of its source, or even diverge from its source, which could lead to horrible chaos. This is basically the problem of a computed value with a setter, but in a distributed context. The way to avoid all this is for derivation push operations to always push to their sources, not themselves. The derivation is then updated in the normal way as the source propagates. But between the necessary source and the derivation lies any number of intermediate derivations. So finding the true sources is non-trivial. Also, derivations are meant to be optimally generic and composable. Requiring them to be aware of their sources introduces harmful coupling. For all these reasons, push capability on derivations seems like a bad idea. If push capability is desired, the derivation's downstream part should graduate to a source, and the derivation's upstream part should instead be a sink that generates push events on the new source.
6. The Redound paradigm should produce unidirectional graphs, hence, no cycles. However, it is hard in general to identify this so the framework can complain preemptively and accurately instead of breaking.
7. It's inevitable that apps will write to the same data source they read from. In most cases this is fine. However, it raises the possibility of apps creating infinite loops whose connections extend beyond the current runtime. Hopefully Redound will make this less likely, not more likely. But this should be considered.